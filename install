#!/bin/bash

if [ "$0" == "bash" ]; then
    echo "cloning scottidler/mysetup"
    git clone https://github.com/scottidler/mysetup
    cd mysetup
    git pull
    git checkout master
    exec ./install
fi

cd "`dirname "$0"`"

SUDO=$([[ `uname` == *"BSD"* ]] && echo "doas" || echo "sudo")

# A POSIX variable
# Reset in case getopts has been used previously in the shell.
OPTIND=1

# Initialize our own variables:

LIST=false
VERBOSE=false
SECTION=""
VAR=""

MANIFEST="manifest.cfg"
PKG=()
PPA=()
APT=()
DNF=()
PIP=()
GIT=()

function realpath() {
    echo "$(cd "$(dirname "$1")"; pwd)/$(basename "$1")"
}

function show() {
    local VAR=$1[@]
    if [ -n "${!VAR[@]}" ]; then
        echo "$1 ="
    fi
    for var in ${!VAR}; do
        echo "    $var"
    done
}

while getopts "h?lvs:v:" opt; do
    case "$opt" in
    h|\?)
        usage
        ;;
    s)  SECTION=$OPTARG
        ;;
    v)  VAR=$OPTARG
        ;;
    l)
        LIST=true
        ;;
    v)  VERBOSE=true
        ;;
    esac
done

shift $((OPTIND-1))
[ "$1" = "--" ] && shift

for file in `find root/ -type f && find root/ -type l`; do
    link="${file#root*}"
    file=`realpath $file`
    if [ -f "$link" ] && [ "$file" != "`readlink $link`" ]; then
        echo "backing up $link.bak"
        $SUDO mv $link $link.bak
    fi
    if [ -f "$link" ]; then
        echo "already exists; skipping $link"
    else
        echo "creating symlink: $link -> $file"
        mkdir -p `dirname $link`
        $SUDO ln -s $file $link
    fi
done

while IFS=$'\n' read line; do
    line="${line//[[:space:]]/}"
    if [ -z "$line" ]; then
        continue
    fi

    if [[ $line == \[*] ]]; then
        IFS="[]"
        set $line
        section=$2
        unset var
        unset val
        continue
    elif [ -n "$SECTION" ] && [ -n "$section" ]; then
        if ! [[ "$section" =~ "$SECTION" ]]; then
            continue
        fi
    fi

    if [[ "$line" =~ "=" ]]; then
        IFS="="
        set $line
        var=$1
        val=$2
    else
        val=$line
    fi

    if [ -n "$val" ]; then
        case $var in
        pkg) PKG+=($val) ;;
        ppa) hash apt-get 2> /dev/null && PPA+=($val) ;;
        apt) hash apt-get 2> /dev/null && APT+=($val) ;;
        dnf) hash dnf 2> /dev/null && DNF+=($val) ;;
        pip) hash pip 2> /dev/null && PIP+=($val) ;;
        git) hash git 2> /dev/null && GIT+=($val) ;;
        esac
    fi
done < $MANIFEST

if $LIST; then
    show "PKG"
    show "PPA"
    show "APT"
    show "DNF"
    show "PIP"
    show "GIT"
    exit 1
fi

mkdir -p repos
for git in "${GIT[@]}"; do
    [ -d "repos/$git" ] || git clone https://github.com/$git repos/$git
    (cd repos/$git && pwd && git pull && git checkout HEAD)
done

if hash apt-get 2> /dev/null; then
    $SUDO apt-get update && $SUDO apt-get upgrade -y
    $SUDO apt-get install -y software-properties-common

    for ppa in "${PPA[@]}"; do
        ppas=`find /etc/apt/ -name *.list | xargs cat | grep  ^[[:space:]]*deb | grep -v deb-src`
        if [[ $ppas != *"$ppa"* ]]; then
            $SUDO add-apt-repository -y "ppa:$ppa"
        fi
    done
    [ ${#PPA[@]} -eq 0 ] || $SUDO apt-get update -y
    [ ${#PKG[@]} -eq 0 ] || $SUDO apt-get install -y "${PKG[@]}"
    [ ${#APT[@]} -eq 0 ] || $SUDO apt-get install -y "${APT[@]}"
elif hash dnf 2> /dev/null; then
    $SUDO dnf update -y
    [ ${#PKG[@]} -eq 0 ] || $SUDO dnf install --dry-run "${PKG[@]}"
    [ ${#DNF[@]} -eq 0 ] || $SUDO install --dry-run "${DNF[@]}"
fi

if hash pip 2> /dev/null; then
    [ ${#PIP[@]} -eq 0 ] || $SUDO -H pip install -U "${PIP[@]}"
fi

exit 0

